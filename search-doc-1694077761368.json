[{"title":"Contributing","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/contributing/","content":"Contributing","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/architecture/","content":"Architecture","keywords":""},{"title":"Erlang Error Index","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/","content":"Erlang Error Index","keywords":""},{"title":"Feature Gallery","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/feature-gallery/","content":"Feature Gallery","keywords":""},{"title":"Get Started","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/get-started/","content":"Get Started","keywords":""},{"title":"Emacs","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/get-started/emacs/","content":"Emacs","keywords":""},{"title":"VS Code","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/get-started/vscode/","content":"VS Code","keywords":""},{"title":"Code Actions (a.k.a. Assists)","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/contributing/code-actions/","content":"","keywords":""},{"title":"The Code Action requestâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#the-code-action-request","content":"Code actions are requested by the editor using the textDocument/codeAction LSP request. Code action requests are handled by the handlers::handle_code_action function in the elp crate. "},{"title":"Adding a new code actionâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#adding-a-new-code-action","content":"In this section we will go through the process of adding a new code action from scratch. The code action (or assist) will suggest the user to delete a function, if it is deemed as unused by the Erlang compiler. "},{"title":"Creating the handlerâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#creating-the-handler","content":"Let's start by creating a new file named delete_function.rs, containing a single function declaration: crates/ide_assists/src/handlers/delete_function.rs use crate::assist_context::{Assists, AssistContext}; pub(crate) fn delete_function(acc: &amp;mut Assists, ctx: &amp;AssistContext) -&gt; Option&lt;()&gt; { todo!() }  Before we can start implementing our code action, there's one more thing we need to do: ensure our new function is invoked by adding it to the list of ELP assists. Open the crates/ide_assists/src/lib.rs file and amend the list of handlers: crates/ide_assists/src/lib.rs mod handlers { [...] mod delete_function [...] pub(crate) fn all() -&gt; &amp;'static [Handler] { &amp;[ [...] delete_function:delete_function, [...] ] } }  "},{"title":"Adding a test caseâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#adding-a-test-case","content":"The easiest way to verify our new code action behaves in the expected way is to start with a test case. ELP allows us to write tests in a very intuitive and straightforward way. Add the following to the delete_function.rs file: crates/ide_assists/src/handlers/delete_function.rs #[cfg(test)] mod tests { use expect_test::expect; use super::*; use crate::tests::*; #[test] fn test_delete_unused_function() { check_assist( delete_function, &quot;Remove the unused function `heavy_calculations/1`&quot;, r#&quot; -module(life). heavy_cal~culations(X) -&gt; %% ^^^^^^^^^^^^^^^^^^^ ðŸ’¡ L1230: Function heavy_calculations/1 is unused X. meaning() -&gt; 42. &quot;#, expect![[ r#&quot; -module(life). meaning() -&gt; 42. &quot;#]], ) } }  There is a lot happening here, so let's go through the code. We are defining a new test, named test_delete_unused_function, which uses an auxiliary function (check_assist) to verify that a given assist behaves as expected. The check_assist function takes 4 arguments: The assist handler (delete_function)A label for the assistAn input fixture representing what the code looks like before a fix is appliedAn output fixture (wrapped in an expect macro) showing what the code looks like after a fix is applied The ~ in the first snippet represents the cursor position. We are asserting that - given a diagnostic message pointing to the unused function - if the user triggers the respective code action when the cursor is hovering the function name range, the unused function gets deleted. Let's try running the test, it should fail with a not yet implemented error: $ cargo test --package elp_ide_assists --lib -- handlers::delete_function::tests::test_delete_unused_function --exact --nocapture [...] ---- handlers::delete_function::tests::test_delete_unused_function stdout ---- thread 'handlers::delete_function::tests::test_delete_unused_function' panicked at 'not yet implemented', crates/ide_assists/src/handlers/delete_function.rs:21:5 [...]  "},{"title":"Diagnostic Annotations and Error Codesâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#diagnostic-annotations-and-error-codes","content":"Before starting with the actual implementation, let's for a second go back to the syntax we used to specify the unused function diagnostic: %% ^^^^^^^^^^^^^^^^^^^ ðŸ’¡ L1230: Function heavy_calculations/1 is unused  This is a test annotation which is used by the ELP testing framework to populate the &quot;context&quot; which is passed to our handler. This is a way to simulate diagnostics coming from external sources (such as the Erlang compiler or a linter), which would be received by the Language Server as part of a textDocument/codeAction request. The annotation has the following format: [\\s]%% [^]* ðŸ’¡ CODE: MESSAGE  Essentially, a number of spaces, followed by the %% which resembles an Erlang comment, a light bulb, a code identifying the diagnostic type and a string message. The code is an unofficial error code which is emitted by both ELP's Erlang Service (see the erlang_service:make_code/2 function in erlang_service/src/erlang_service.erl) and by the Erlang LS language server. The idea is to eventually standardize Erlang error messages and to build what, in the end, should be similar to the Rust or Haskell error indexes. In our case, L1230 is the error corresponding to the unused_function diagnostic. The message is a free text string that accompanies the diagnostic. "},{"title":"Matching on the diagnostic error codeâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#matching-on-the-diagnostic-error-code","content":"To be able to match the L1230 error code, we need to add a new variant to the AssistContextDiagnosticCode enum. Open the crates/ide_db/src/assists.rs file and include the new error code. Don't forget to map it to the L1230 string. crates/ide_db/src/assists.rs pub enum AssistContextDiagnosticCode { UnusedFunction, // &lt;--- Add this [...] UnusedVariable, } impl FromStr for AssistContextDiagnosticCode { type Err = String; fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; { match s { &quot;L1230&quot; =&gt; Ok(AssistContextDiagnosticCode::UnusedFunction), // &lt;--- Add this [...] &quot;L1268&quot; =&gt; Ok(AssistContextDiagnosticCode::UnusedVariable), unknown =&gt; Err(format!(&quot;Unknown AssistContextDiagnosticCode: '{unknown}'&quot;)), } } }  We are all set. Time to implement the delete_function function! "},{"title":"The implementationâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#the-implementation","content":"Let's look at our function again. pub(crate) fn delete_function(acc: &amp;mut Assists, ctx: &amp;AssistContext) -&gt; Option&lt;()&gt; { todo!() }  We have two input arguments: a mutable accumulator which contains the list of code actions (or assists) which we want to return and a context, from which we can extract diagnostics. The following code iterates through the list of diagnostics and, for each diagnostic matching the UnusedFunction kind, prints the diagnostic for debugging purposes. We return Some(()) to comply with the function signature. use elp_ide_db::assists::AssistContextDiagnosticCode; [...] pub(crate) fn delete_function(acc: &amp;mut Assists, ctx: &amp;AssistContext) -&gt; Option&lt;()&gt; { for d in ctx.diagnostics { if let AssistContextDiagnosticCode::UnusedFunction = d.code { dbg!(d); todo!() } } Some(()) } [...]  If we run the test, we can see what a diagnostic looks like: $ cargo test --package elp_ide_assists --lib -- handlers::delete_function::tests::test_delete_unused_function --exact --nocapture [...] running 1 test [crates/ide_assists/src/handlers/delete_function.rs:25] d = AssistContextDiagnostic { code: UnusedFunction, message: &quot;Function heavy_calculations/1 is unused&quot;, range: 24..40, } [...]  The diagnostic contains the error code and message, together with its range. What we want to do is: Find the function declaration which is pointed by the diagnostic rangeCreate a code action to remove the function declaration and add it to the accumulator How do we find the element which the range covers? Context to the rescue! There's a handy find_node_at_custom_offset function we can use. The offset here indicates the number of bytes from the beginning of the file. We can use the beginning of the diagnostic range for our purposes. let function_declaration: ast::FunDecl = ctx.find_node_at_custom_offset::&lt;ast::FunDecl&gt;(d.range.start())?; let function_range = function_declaration.syntax().text_range();  Let's extract the function name/arity and produce a nice message for the user: let function_name = function_declaration.name()?; let function_arity = function_declaration.arity_value()?; let message = format!(&quot;Remove the unused function `{function_name}/{function_arity}`&quot;);  With the information we have, we can now create a new code action and add it to the accumulator: let id = AssistId(&quot;delete_function&quot;, AssistKind::QuickFix); let function_range = function_declaration.syntax().text_range(); acc.add(id, message, function_range, |builder| { builder.edit_file(ctx.frange.file_id); builder.delete(function_range) }, );  The add function takes four arguments: An internal AssistId made of a unique string (the &quot;delete_function&quot; string in our case) and a Kind. We are specifying QuickFix in our case, but have a look to the LSP specifications to get a list of the available kinds.A message which will be rendered to the user (&quot;Delete the unused function: [FUNCTION_NAME]&quot;)The range of the function. Notice how the range we got from the diagnostic was covering only the name of the function, but we need to delete the whole function, so we need to pass the full range.A function which takes a builder as its input and uses it to manipulate the source file. Here we are saying that we want to edit the current file (we extract the file_id from the ctx context) and that we simply want to delete the range of the function declaration. Yes. It's as simple as that. For completeness, here is the full function implementation: pub(crate) fn delete_function(acc: &amp;mut Assists, ctx: &amp;AssistContext) -&gt; Option&lt;()&gt; { for d in ctx.diagnostics { if let AssistContextDiagnosticCode::UnusedFunction = d.code { let function_declaration: ast::FunDecl = ctx.find_node_at_custom_offset::&lt;ast::FunDecl&gt;(d.range.start())?; let function_name = function_declaration.name()?; let function_arity = function_declaration.arity_value()?; let function_range = function_declaration.syntax().text_range(); let id = AssistId(&quot;delete_function&quot;, AssistKind::QuickFix); let message = format!(&quot;Remove the unused function `{function_name}/{function_arity}`&quot;); acc.add(id, message, function_range, |builder| { builder.edit_file(ctx.frange.file_id); builder.delete(function_range) }); } } Some(()) }  You can look at existing assists for more complex manipulation examples. Try it yourself What we wrote is a unit test, but there's nothing better than checking ourselves the behaviour in the IDE. Compile the elp executable: cargo build  Then visit the Erlang extension settings page and edit the elp.path value to point to the newly built executable, which should reside in: ./debug/elp  Open VS Code (or reload the window if you have it already open) and visit an Erlang file which contains an unused function. You should see something like:  If that worked, congratulations! You managed to write your first ELP code action! "}]