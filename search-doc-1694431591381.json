[{"title":"Contributing","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/contributing/","content":"Contributing","keywords":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/architecture/","content":"Architecture","keywords":""},{"title":"Erlang Error Index","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/","content":"","keywords":""},{"title":"Namespacesâ€‹","type":1,"pageTitle":"Erlang Error Index","url":"/erlang-language-platform/docs/erlang-error-index/#namespaces","content":"Error codes are grouped by using namespaces. Each namespace is associated to the tool that emits those error codes. Are we missing a tool? Reserve a namespace by making a Pull Request! Tool\tNamespaceErlang Compiler\tC Erlang EPP Dodger\tD Erlang Pre-processor\tE Erlang Linter\tL Erlang Parser\tP Erlang Scanner\tS WhatsApp ELP\tW "},{"title":"Ignoring Diagnosticsâ€‹","type":1,"pageTitle":"Erlang Error Index","url":"/erlang-language-platform/docs/erlang-error-index/#ignoring-diagnostics","content":"ELP provides a generic mechanism to ignore instances of an error code. Given the error code X12345 you can ignore a diagnostic by prepending the offending line with a special annotation: % elp:ignore X12345  It is possible to ignore multiple error codes at once: % elp:ignore X12345 Y56789  "},{"title":"About","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/c/about/","content":"About","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/d/about/","content":"About","keywords":""},{"title":"Code Actions (a.k.a. Assists)","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/contributing/code-actions/","content":"","keywords":""},{"title":"The Code Action requestâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#the-code-action-request","content":"Code actions are requested by the editor using the textDocument/codeAction LSP request. Code action requests are handled by the handlers::handle_code_action function in the elp crate. "},{"title":"Adding a new code actionâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#adding-a-new-code-action","content":"In this section we will go through the process of adding a new code action from scratch. The code action (or assist) will suggest the user to delete a function, if it is deemed as unused by the Erlang compiler. "},{"title":"Creating the handlerâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#creating-the-handler","content":"Let's start by creating a new file named delete_function.rs, containing a single function declaration: crates/ide_assists/src/handlers/delete_function.rs use crate::assist_context::{Assists, AssistContext}; pub(crate) fn delete_function(acc: &amp;mut Assists, ctx: &amp;AssistContext) -&gt; Option&lt;()&gt; { todo!() }  Before we can start implementing our code action, there's one more thing we need to do: ensure our new function is invoked by adding it to the list of ELP assists. Open the crates/ide_assists/src/lib.rs file and amend the list of handlers: crates/ide_assists/src/lib.rs mod handlers { [...] mod delete_function [...] pub(crate) fn all() -&gt; &amp;'static [Handler] { &amp;[ [...] delete_function:delete_function, [...] ] } }  "},{"title":"Adding a test caseâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#adding-a-test-case","content":"The easiest way to verify our new code action behaves in the expected way is to start with a test case. ELP allows us to write tests in a very intuitive and straightforward way. Add the following to the delete_function.rs file: crates/ide_assists/src/handlers/delete_function.rs #[cfg(test)] mod tests { use expect_test::expect; use super::*; use crate::tests::*; #[test] fn test_delete_unused_function() { check_assist( delete_function, &quot;Remove the unused function `heavy_calculations/1`&quot;, r#&quot; -module(life). heavy_cal~culations(X) -&gt; %% ^^^^^^^^^^^^^^^^^^^ ðŸ’¡ L1230: Function heavy_calculations/1 is unused X. meaning() -&gt; 42. &quot;#, expect![[ r#&quot; -module(life). meaning() -&gt; 42. &quot;#]], ) } }  There is a lot happening here, so let's go through the code. We are defining a new test, named test_delete_unused_function, which uses an auxiliary function (check_assist) to verify that a given assist behaves as expected. The check_assist function takes 4 arguments: The assist handler (delete_function)A label for the assistAn input fixture representing what the code looks like before a fix is appliedAn output fixture (wrapped in an expect macro) showing what the code looks like after a fix is applied The ~ in the first snippet represents the cursor position. We are asserting that - given a diagnostic message pointing to the unused function - if the user triggers the respective code action when the cursor is hovering the function name range, the unused function gets deleted. Let's try running the test, it should fail with a not yet implemented error: $ cargo test --package elp_ide_assists --lib -- handlers::delete_function::tests::test_delete_unused_function --exact --nocapture [...] ---- handlers::delete_function::tests::test_delete_unused_function stdout ---- thread 'handlers::delete_function::tests::test_delete_unused_function' panicked at 'not yet implemented', crates/ide_assists/src/handlers/delete_function.rs:21:5 [...]  "},{"title":"Diagnostic Annotations and Error Codesâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#diagnostic-annotations-and-error-codes","content":"Before starting with the actual implementation, let's for a second go back to the syntax we used to specify the unused function diagnostic: %% ^^^^^^^^^^^^^^^^^^^ ðŸ’¡ L1230: Function heavy_calculations/1 is unused  This is a test annotation which is used by the ELP testing framework to populate the &quot;context&quot; which is passed to our handler. This is a way to simulate diagnostics coming from external sources (such as the Erlang compiler or a linter), which would be received by the Language Server as part of a textDocument/codeAction request. The annotation has the following format: [\\s]%% [^]* ðŸ’¡ CODE: MESSAGE  Essentially, a number of spaces, followed by the %% which resembles an Erlang comment, a light bulb, a code identifying the diagnostic type and a string message. The code is an unofficial error code which is emitted by both ELP's Erlang Service (see the erlang_service:make_code/2 function in erlang_service/src/erlang_service.erl) and by the Erlang LS language server. The idea is to eventually standardize Erlang error messages and to build what, in the end, should be similar to the Rust or Haskell error indexes. In our case, L1230 is the error corresponding to the unused_function diagnostic. The message is a free text string that accompanies the diagnostic. "},{"title":"Matching on the diagnostic error codeâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#matching-on-the-diagnostic-error-code","content":"To be able to match the L1230 error code, we need to add a new variant to the AssistContextDiagnosticCode enum. Open the crates/ide_db/src/assists.rs file and include the new error code. Don't forget to map it to the L1230 string. crates/ide_db/src/assists.rs pub enum AssistContextDiagnosticCode { UnusedFunction, // &lt;--- Add this [...] UnusedVariable, } impl FromStr for AssistContextDiagnosticCode { type Err = String; fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; { match s { &quot;L1230&quot; =&gt; Ok(AssistContextDiagnosticCode::UnusedFunction), // &lt;--- Add this [...] &quot;L1268&quot; =&gt; Ok(AssistContextDiagnosticCode::UnusedVariable), unknown =&gt; Err(format!(&quot;Unknown AssistContextDiagnosticCode: '{unknown}'&quot;)), } } }  We are all set. Time to implement the delete_function function! "},{"title":"The implementationâ€‹","type":1,"pageTitle":"Code Actions (a.k.a. Assists)","url":"/erlang-language-platform/docs/contributing/code-actions/#the-implementation","content":"Let's look at our function again. pub(crate) fn delete_function(acc: &amp;mut Assists, ctx: &amp;AssistContext) -&gt; Option&lt;()&gt; { todo!() }  We have two input arguments: a mutable accumulator which contains the list of code actions (or assists) which we want to return and a context, from which we can extract diagnostics. The following code iterates through the list of diagnostics and, for each diagnostic matching the UnusedFunction kind, prints the diagnostic for debugging purposes. We return Some(()) to comply with the function signature. use elp_ide_db::assists::AssistContextDiagnosticCode; [...] pub(crate) fn delete_function(acc: &amp;mut Assists, ctx: &amp;AssistContext) -&gt; Option&lt;()&gt; { for d in ctx.diagnostics { if let AssistContextDiagnosticCode::UnusedFunction = d.code { dbg!(d); todo!() } } Some(()) } [...]  If we run the test, we can see what a diagnostic looks like: $ cargo test --package elp_ide_assists --lib -- handlers::delete_function::tests::test_delete_unused_function --exact --nocapture [...] running 1 test [crates/ide_assists/src/handlers/delete_function.rs:25] d = AssistContextDiagnostic { code: UnusedFunction, message: &quot;Function heavy_calculations/1 is unused&quot;, range: 24..40, } [...]  The diagnostic contains the error code and message, together with its range. What we want to do is: Find the function declaration which is pointed by the diagnostic rangeCreate a code action to remove the function declaration and add it to the accumulator How do we find the element which the range covers? Context to the rescue! There's a handy find_node_at_custom_offset function we can use. The offset here indicates the number of bytes from the beginning of the file. We can use the beginning of the diagnostic range for our purposes. let function_declaration: ast::FunDecl = ctx.find_node_at_custom_offset::&lt;ast::FunDecl&gt;(d.range.start())?; let function_range = function_declaration.syntax().text_range();  Let's extract the function name/arity and produce a nice message for the user: let function_name = function_declaration.name()?; let function_arity = function_declaration.arity_value()?; let message = format!(&quot;Remove the unused function `{function_name}/{function_arity}`&quot;);  With the information we have, we can now create a new code action and add it to the accumulator: let id = AssistId(&quot;delete_function&quot;, AssistKind::QuickFix); let function_range = function_declaration.syntax().text_range(); acc.add(id, message, function_range, |builder| { builder.edit_file(ctx.frange.file_id); builder.delete(function_range) }, );  The add function takes four arguments: An internal AssistId made of a unique string (the &quot;delete_function&quot; string in our case) and a Kind. We are specifying QuickFix in our case, but have a look to the LSP specifications to get a list of the available kinds.A message which will be rendered to the user (&quot;Delete the unused function: [FUNCTION_NAME]&quot;)The range of the function. Notice how the range we got from the diagnostic was covering only the name of the function, but we need to delete the whole function, so we need to pass the full range.A function which takes a builder as its input and uses it to manipulate the source file. Here we are saying that we want to edit the current file (we extract the file_id from the ctx context) and that we simply want to delete the range of the function declaration. Yes. It's as simple as that. For completeness, here is the full function implementation: pub(crate) fn delete_function(acc: &amp;mut Assists, ctx: &amp;AssistContext) -&gt; Option&lt;()&gt; { for d in ctx.diagnostics { if let AssistContextDiagnosticCode::UnusedFunction = d.code { let function_declaration: ast::FunDecl = ctx.find_node_at_custom_offset::&lt;ast::FunDecl&gt;(d.range.start())?; let function_name = function_declaration.name()?; let function_arity = function_declaration.arity_value()?; let function_range = function_declaration.syntax().text_range(); let id = AssistId(&quot;delete_function&quot;, AssistKind::QuickFix); let message = format!(&quot;Remove the unused function `{function_name}/{function_arity}`&quot;); acc.add(id, message, function_range, |builder| { builder.edit_file(ctx.frange.file_id); builder.delete(function_range) }); } } Some(()) }  You can look at existing assists for more complex manipulation examples. Try it yourself What we wrote is a unit test, but there's nothing better than checking ourselves the behaviour in the IDE. Compile the elp executable: cargo build  Then visit the Erlang extension settings page and edit the elp.path value to point to the newly built executable, which should reside in: ./debug/elp  Open VS Code (or reload the window if you have it already open) and visit an Erlang file which contains an unused function. You should see something like:  If that worked, congratulations! You managed to write your first ELP code action! "},{"title":"About","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/e/about/","content":"About","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/p/about/","content":"About","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/l/about/","content":"About","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/s/about/","content":"About","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/about/","content":"About The W namespace is reserved for error codes emitted by the WhatsApp Erlang Language Platform.","keywords":""},{"title":"W0001 - Module Mismatch","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0001/","content":"","keywords":""},{"title":"Errorâ€‹","type":1,"pageTitle":"W0001 - Module Mismatch","url":"/erlang-language-platform/docs/erlang-error-index/w/W0001/#error","content":"-module(bar). %% ^^^ error: Module name (bar) does not match file name (foo)  "},{"title":"Explanationâ€‹","type":1,"pageTitle":"W0001 - Module Mismatch","url":"/erlang-language-platform/docs/erlang-error-index/w/W0001/#explanation","content":"The error message is indicating that the module name specified in the -module attribute (bar) does not match the file name of the source code file (foo.erl). In Erlang, the module name - an atom - has to be same as the file name minus the extension .erl. This is to ensure code loading works as intended. To fix this error, you should either change the -module directive to match the file name (i.e. -module(foo)) or rename the file to match the module name (i.e. foo.erl -&gt; bar.erl). "},{"title":"W0002 - Unused Macro","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0002/","content":"","keywords":""},{"title":"Errorâ€‹","type":1,"pageTitle":"W0002 - Unused Macro","url":"/erlang-language-platform/docs/erlang-error-index/w/W0002/#error","content":"-module(main). -define(MEANING_OF_LIFE, 42). %% ^^^^^^^^^^^^^^^ warning: Unused macro (MEANING_OF_LIFE)  "},{"title":"Explanationâ€‹","type":1,"pageTitle":"W0002 - Unused Macro","url":"/erlang-language-platform/docs/erlang-error-index/w/W0002/#explanation","content":"The error message is indicating that the macro MEANING_OF_LIFE is defined but not used anywhere in the code. To fix this warning, you should either use the macro somewhere in the code or remove the definition of the macro if it is no longer needed. "},{"title":"W0000 - Bound Variable in Pattern","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0000/","content":"","keywords":""},{"title":"Errorâ€‹","type":1,"pageTitle":"W0000 - Bound Variable in Pattern","url":"/erlang-language-platform/docs/erlang-error-index/w/W0000/#error","content":"caution This error code is not emitted any longer. Semantic tokens are used instead. "},{"title":"Explanationâ€‹","type":1,"pageTitle":"W0000 - Bound Variable in Pattern","url":"/erlang-language-platform/docs/erlang-error-index/w/W0000/#explanation","content":"Inspired by Elixir's pinning operator, this diagnostic marks variables in patterns, if they are already bound. This can be problematic if the binding is not intentional and it can lead to subtle bugs. Consider the following code snippet: handle_request(Message) -&gt; case next_action() of {send, Message} -&gt; ... {error, Error} ... end  The pattern on line 3 will only be matched if and only if the Message returned by the call to next_action/1 is the same as the one on line 1. This behaviour could be intentional or not. If not, it can easily lead to bugs. An alternative, more explicit, way to express that behaviour - when intentional - could be: handle_request(Message) -&gt; case next_action() of {send, ActionMessage} when ActionMessage =:= Message -&gt; ... {error, Error} ... end  "},{"title":"W0004 - Missing","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0004/","content":"W0004 - Missing","keywords":""},{"title":"W0003 - Unused Record Field","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0003/","content":"","keywords":""},{"title":"Errorâ€‹","type":1,"pageTitle":"W0003 - Unused Record Field","url":"/erlang-language-platform/docs/erlang-error-index/w/W0003/#error","content":"-module(main). -export([main/1]). -record(used_field, {field_a, field_b = 42}). -record(unused_field, {field_c, field_d}). %% ^^^^^^^ warning: Unused record field (unused_field.field_d) main(#used_field{field_a = A, field_b = B}) -&gt; {A, B}; main(R) -&gt; R#unused_field.field_c.  "},{"title":"Explanationâ€‹","type":1,"pageTitle":"W0003 - Unused Record Field","url":"/erlang-language-platform/docs/erlang-error-index/w/W0003/#explanation","content":"The error message is indicating that the field field_d in the record unused_field is defined but not used anywhere in the code. In Erlang, records are a way to define a data structure with named fields. However, if a field is defined but not used, it is considered unused and will generate a warning when the code is compiled. To fix this warning, you should either use the field somewhere in the code or remove the definition of the field if it is no longer needed. It's worth noting that the field field_c in the same record is being used in the function main/1, so it's not considered unused. "},{"title":"W0005 - Mutable Variable Bug","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0005/","content":"","keywords":""},{"title":"Errorâ€‹","type":1,"pageTitle":"W0005 - Mutable Variable Bug","url":"/erlang-language-platform/docs/erlang-error-index/w/W0005/#error","content":"-module(main). -export([test/0]). test() -&gt; Zero = 0, One = 1, Result = One = Zero, %% ^^^^^^^^^^^^^^^^^^^ error: Possible mutable variable bug io:format(&quot;~p ~p~n&quot;, [Zero, One]), Result.  "},{"title":"Explanationâ€‹","type":1,"pageTitle":"W0005 - Mutable Variable Bug","url":"/erlang-language-platform/docs/erlang-error-index/w/W0005/#explanation","content":"The error message indicates that this specific pattern could trigger a known bug with certain OTP releases. Earlier (i.e. &lt; OTP 26) Erlang releases were affected by a subtle bug which caused the pattern matching operator to incorrectly mutate variables. By compiling the above snippet on one of the problematic releases you'd get: 1&gt; test:test(). 0 0 0  The code should have crashed with a pattern match error. Instead, the variable One mutated from the original value 1 to the value 0. "},{"title":"W0006 - Statement Has No Effect","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0006/","content":"","keywords":""},{"title":"Errorâ€‹","type":1,"pageTitle":"W0006 - Statement Has No Effect","url":"/erlang-language-platform/docs/erlang-error-index/w/W0006/#error","content":"-module(main). test_foo(_Config) -&gt; do_something(), ok, %%% ^^ warning: this statement has no effect do_something_else(), bar, %%% ^^^ warning: this statement has no effect ok. do_something() -&gt; ok. do_something_else() -&gt; ok.  "},{"title":"Explanationâ€‹","type":1,"pageTitle":"W0006 - Statement Has No Effect","url":"/erlang-language-platform/docs/erlang-error-index/w/W0006/#explanation","content":"The error message is indicating that the statements ok and bar (atoms in this case) have no effect in the code. The atoms in the above snippet are used as a standalone statement and they have no effect on the program. To fix these warnings, you should either remove the unused statements or change the code so that they are used. "},{"title":"W0007 - Trivial Match","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0007/","content":"","keywords":""},{"title":"Errorâ€‹","type":1,"pageTitle":"W0007 - Trivial Match","url":"/erlang-language-platform/docs/erlang-error-index/w/W0007/#error","content":"-module(main). do_foo() -&gt; X = 42, Y = 42, X = X, %%% ^^^^^ warning: match is redundant X = Y.  "},{"title":"Explanationâ€‹","type":1,"pageTitle":"W0007 - Trivial Match","url":"/erlang-language-platform/docs/erlang-error-index/w/W0007/#explanation","content":"The error message is indicating that the statement X = X is redundant. Since the pattern (the part on the left of the = and the expression (the part on the right of the =) are the same and given that in Erlang variables are immutable (once a value is assigned to a variable it cannot be changed), the operation will always succeed. To fix this warning, you should remove the redundant assignment. "},{"title":"W0008 - Unreachable Test","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0008/","content":"","keywords":""},{"title":"Errorâ€‹","type":1,"pageTitle":"W0008 - Unreachable Test","url":"/erlang-language-platform/docs/erlang-error-index/w/W0008/#error","content":" -module(my_SUITE). -export([all/0]). -export([a/1, b/1]). all() -&gt; [a]. a(_Config) -&gt; ok. b(_Config) -&gt; %% ^ warning: Unreachable test (b/1) ok.  "},{"title":"Explanationâ€‹","type":1,"pageTitle":"W0008 - Unreachable Test","url":"/erlang-language-platform/docs/erlang-error-index/w/W0008/#explanation","content":"The error message is indicating that the b test case is not reachable by the Common Test testing framework and that it won't be executed by the testing framework. In Common Test, test cases are auto-discovered by the framework via the all/0 and groups/1 function. A function is deemed an unreachable test if: the function belongs to a module name ending with _SUITEthe function has arity 1the function is exportedthe function is not reachable via the all/0 and group/0 functions and it is therefore not executed by the Erlang Common Test framework. In the above snippet, the b/1 function falls into that category since all of the above apply. To fix this warning you should either remove the test cases (if not necessary any longer) or make it reachable via the all/0 function. Sometimes it is intentional to have test cases which are defined but not running (e.g. they are occasionally run manually). In such case you can silent the warning by using an ELP ignore annotation. "},{"title":"W0009 - Redundant Assignment","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0009/","content":"W0009 - Redundant Assignment","keywords":""},{"title":"W0010 - Unused Function Argument","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0010/","content":"W0010 - Unused Function Argument","keywords":""},{"title":"W0011 - Application Get Env","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0011/","content":"W0011 - Application Get Env","keywords":""},{"title":"W0012 - Missing Compile Warn Missing Spec","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0012/","content":"W0012 - Missing Compile Warn Missing Spec","keywords":""},{"title":"W0013 - Misspelled Attribute","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0013/","content":"W0013 - Misspelled Attribute","keywords":""},{"title":"W0014 - Cross Node Eval","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0014/","content":"W0014 - Cross Node Eval","keywords":""},{"title":"W0015 - Dependent Header","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0015/","content":"W0015 - Dependent Header","keywords":""},{"title":"W0016 - Deprecated Function","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/erlang-error-index/w/W0016/","content":"W0016 - Deprecated Function","keywords":""},{"title":"Get Started","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/get-started/","content":"Get Started","keywords":""},{"title":"Emacs","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/get-started/emacs/","content":"Emacs","keywords":""},{"title":"VS Code","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/get-started/vscode/","content":"VS Code","keywords":""},{"title":"Feature Gallery","type":0,"sectionRef":"#","url":"/erlang-language-platform/docs/feature-gallery/","content":"","keywords":""},{"title":"Syntax Highlightingâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#syntax-highlighting","content":"VS Code "},{"title":"Semantic Syntax Highlightingâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#semantic-syntax-highlighting","content":"In addition to traditional syntax highlighting, ELP can highlight the code semantically. As an example, exported functions can be rendered differently from un-exported ones and deprecated functions are clearly marked via a strikethrough. VS Code We currently support the following token modifiers: Token Modifier\tSemantic Meaningbound\tThe variable used in a pattern is already bound exported_function\tThe given function is exported deprecated_function\tThe given function is marked as deprecated "},{"title":"Go To Definitionâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#go-to-definition","content":"Navigate to the definition of a given identifier. Currently supported for: ModulesFunctionsRecordsRecord fieldsTypesBehavioursMacrosHeadersVariables "},{"title":"Find Referencesâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#find-references","content":"Show/peek references to the item at the cursor location. VS Code Currently supported for all items listed in the Go To Definition section. "},{"title":"Workspace Symbolsâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#workspace-symbols","content":"Quickly navigate to a symnol in the workspace. VS Code Currently supported for: Modules "},{"title":"Foldingâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#folding","content":"Collapse/expand sections of the code to focus on what matters. Currently supported for: Functions "},{"title":"Call Hierarchyâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#call-hierarchy","content":"Navigate callers and callees for a given function. "},{"title":"Documentation on Hoverâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#documentation-on-hover","content":"Extract and present EDoc information when hovering a function call. "},{"title":"Auto-completionâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#auto-completion","content":"Provide contextual auto-completion to ease writing code. Currently supported for: Module AttributesFunctionsTypesKeywordsMacrosRecordsRecord FieldsVariables "},{"title":"Signature Helpâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#signature-help","content":"Get some guidance while invoking a local or remote function, by previewing argument specific documentation. "},{"title":"Highlight Related Informationâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#highlight-related-information","content":"Focus on an element and its related info at a glance. "},{"title":"Inlay Hintsâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#inlay-hints","content":"Currently supported for all items listed in the Go To Definition section. "},{"title":"Go To Documentationâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#go-to-documentation","content":"Have convenient links to the official Erlang/OTP documentation while hovering a function call. "},{"title":"Diagnosticsâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#diagnostics","content":"In addition to errors and warnings coming directly from the Erlang compiler, ELP provides a number of diagnostics implemented using ELP's own analysis or external tools. "},{"title":"EDocâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#edoc","content":"Show warnings and errors from compiling Erlang EDoc pages for the current module. "},{"title":"Unsafe usage application environmentâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#unsafe-usage-application-environment","content":"While it is technically possible to call application:get_env(Application, Key) from a module belonging to application A using the name of a different application B, this can sometimes represent a bad smell since it could lead to subtle bugs (e.g. application B not being included in the same release. "},{"title":"Cross-node Evaluationâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#cross-node-evaluation","content":"Sometimes you want to prevent direct RPC calls to different nodes. "},{"title":"Dependent Headerâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#dependent-header","content":"Return a warning if a header file is not self-contained. "},{"title":"Deprecated Functionâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#deprecated-function","content":"Similarly to XRef, show a warning if you are invoking a deprecated function. Deprecated functions can either be specified using the -deprecated attribute or via code. When deprecated functions are specified via code, extra information can be included, such as: A severityA descriptive messageA link to external documentation "},{"title":"Effect Free Statementâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#effect-free-statement","content":"Return a diagnostic if a statement is just a literal or a variable. "},{"title":"Head Mismatchâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#head-mismatch","content":"Find mismatches between the clauses of a function declaration. "},{"title":"Missing warn_missing_spec compiler attributeâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#missing-warn_missing_spec-compiler-attribute","content":"Return a warning if a the file does not contain a -compile(warn_missing_spec). or -compile(warn_missing_spec_all). compiler attribute. "},{"title":"Mispelled Attributeâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#mispelled-attribute","content":"Spot attributes with names similar to known attributes. "},{"title":"Module Mismatchâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#module-mismatch","content":"Return an error if the module name does not correspond to the filename. "},{"title":"Mutable Variableâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#mutable-variable","content":"Detect instances for the OTP mutable variable bug. It works by looking for a chain of match expressions where the constituent elements are already bound. E.g.: test() -&gt; Zero = 0, One = 1, Result = One = Zero, ^^^^^^^^^^^^^^^^^^^  "},{"title":"Redundant Assignmentâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#redundant-assignment","content":"Check for redundant assignments before returning. "},{"title":"No-op Callâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#no-op-call","content":"Warn if a function representing a no-op is invoked. "},{"title":"Trivial Matchâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#trivial-match","content":"Return a diagnostic if a match will trivially always succeed. "},{"title":"Unreachable Test Caseâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#unreachable-test-case","content":"In a Common Test suite, tests are defined via a callback function: all/0. Tests can also be grouped together and groups definitions are provided via an additional callback function: groups/0. A test case is deemed unreachable if: A corresponding function with arity 1 existsThe function is exportedThe function is not one of the Common Test callback functionsThe function is not reachable via the all/0 and groups/0 functions "},{"title":"Unused Function Argumentâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#unused-function-argument","content":"Warn about arguments passed through functions but never used. "},{"title":"Unused Includeâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#unused-include","content":"Warn about an -include statement from which nothing is used. "},{"title":"Unused Macroâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#unused-macro","content":"Warn about macros defined in modules (not in header files), but never used. "},{"title":"Unused Record Fieldsâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#unused-record-fields","content":"Warn about record fields which are never used. "},{"title":"Quick Fixes (Assists)â€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#quick-fixes-assists","content":""},{"title":"Add EDocâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#add-edoc","content":"Add a stub for EDoc documentation if not present. "},{"title":"Add Format tagâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#add-format-tag","content":"Add the % @format pragma to opt-in formatting. "},{"title":"Add Implementationâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#add-implementation","content":"Given a -spec attribute, provide a stub for the actual function if not present. "},{"title":"Add Specâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#add-spec","content":"Given a function, provide a stub for the -spec attribute for such a function. "},{"title":"Implement Behaviour Callbacksâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#implement-behaviour-callbacks","content":"Provide stubs for the un-implemented behaviour callbacks. "},{"title":"Refactoringâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#refactoring","content":"ELP contains built-in capabilities for analyzing and refactoring Erlang code. "},{"title":"Extract Functionâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#extract-function","content":"Extract the selected expression(s) into a separate function and invoke it. "},{"title":"Inline Functionâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#inline-function","content":"Reverse of Extract Function. Given a function, replace all invokations with the body of the function. "},{"title":"Create Functionâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#create-function","content":"Add a new function. "},{"title":"Delete Functionâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#delete-function","content":"Remove the entire function. "},{"title":"Extract Variableâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#extract-variable","content":""},{"title":"Ignore Variableâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#ignore-variable","content":"Prepend the variable name with a _ (underscore). "},{"title":"Inline Variableâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#inline-variable","content":"Replace a variable with the RHS (right-hand-side) of a previous assignment. "},{"title":"Bump Variablesâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#bump-variables","content":"Given how variables are immutable in Erlang, it is sometimes common to see patterns such as: handle_request(Request0) -&gt; Request1 = first_do(Request0), Request2 = then_do(Request1), Request3 = then_do(Request2), [...]  This refactoring allows selecting one of the instances and bump all instances afterwars. "},{"title":"Flip Around Separatorâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#flip-around-separator","content":"Given two elements surrounding a separator, flip them. It can be used, for example, to flip the order of two function arguments around a comma. "},{"title":"Test Runnerâ€‹","type":1,"pageTitle":"Feature Gallery","url":"/erlang-language-platform/docs/feature-gallery/#test-runner","content":"Run/Debug Common Test test-cases or an entire test suite via convenient code lenses. Support Common Test groups. "}]